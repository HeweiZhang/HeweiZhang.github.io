{"meta":{"title":"David's Blog","subtitle":null,"description":null,"author":"David-zhw","url":"http://hwzhang.top"},"pages":[{"title":"Categories","date":"2017-03-21T07:20:33.000Z","updated":"2017-03-21T07:09:27.000Z","comments":true,"path":"categories/index.html","permalink":"http://hwzhang.top/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-03-21T07:20:33.000Z","updated":"2017-03-21T07:09:27.000Z","comments":true,"path":"tags/index.html","permalink":"http://hwzhang.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"gradle3.0多渠道打包","slug":"gradle3-0多渠道打包","date":"2017-12-27T09:33:43.000Z","updated":"2017-12-27T09:35:38.732Z","comments":true,"path":"2017/12/27/gradle3-0多渠道打包/","link":"","permalink":"http://hwzhang.top/2017/12/27/gradle3-0多渠道打包/","excerpt":"","text":"android开发中常常会碰到开发环境与生产环境接口地址使用不同域名的情况、甚至要求debug包与release包不同包名，其实这些都可以通过gradle来帮我们完成，再也不用手动改代码，拒绝麻烦与出错，了解gralde的用法，有助于提升生产力。这里仅记录自己开发中碰到的问题及解决方式结合使用场景与实际操作 动态改变接口地址 release与debug版本不同包名 debug使用release版本正式签名 apk打包自动命名 一、比如release版本要求api域名为：https://www.release.\\*,而debug版本为：https://www.test.\\*。我们这里介绍的是通过在Manifest文件中添加变量，同时在gradle中打包时动态的去更改属性的值，应用启动的时候去读取从而动态的改变当前版本的域名 通过gradle修改AndroidManifest.xm meta-data值 12345&lt;!--AndroidManifest.xml--&gt;&lt;!--编译时域名动态切换--&gt;&lt;application&gt;&lt;meta-data android:value=&quot;$&#123;app_version_key&#125;&quot; android:name=&quot;app_version&quot;/&gt;...&lt;/application&gt; app下的gradle中使用manifestPlaceholders来动态替换属性值，格式如下; 12345678910release &#123; manifestPlaceholders = [ app_version_key: &quot;release&quot; ] &#125;debug &#123; manifestPlaceholders = [ app_version_key: &quot;test&quot; ] &#125; 3.由于清单文件中我们的meta-data节点写在application节点根目录下，这里我们在application中去获取该属性的值(其他方式请自行google)1234567891011try &#123; ApplicationInfo info = getPackageManager().getApplicationInfo(getPackageName(), PackageManager.GET_META_DATA); String host = info.metaData.getString(&quot;app_version&quot;); if (host.equals(&quot;test&quot;)) &#123;//测试版 HttpApis.host = &quot;https://www.release.*&quot;; &#125; else &#123;//正式版 HttpApis.host = &quot;https://www.test.*&quot;; &#125; &#125; catch (PackageManager.NameNotFoundException e) &#123; e.printStackTrace(); &#125; 通过上述操作我们已经可以实现打包时，release包与debug包域名分开。上述同样可用在第三方sdk如极光推送、测试版与正式版分开推送，可使用manifestPlaceholders 动态的改变对应的属性值 二、有时候为了测试方便，我们常将正式版与测试版分两个包名打包，从而实现同台手机可以同时安装、拒绝不断的安装卸载操作 1、修改app下的gradle文件,需要注意的一点是在配置了productFlavors后，defaultConfig中的applicationId便会失效12345678910111213141516android&#123; defaultConfig &#123; //applicationId &quot;com.david.smarthome&quot; ... flavorDimensions &quot;versionCode&quot; &#125; productFlavors &#123; appdebug &#123; applicationId &apos;com.david.smarthome_test&apos; &#125; apprelease &#123; applicationId &apos;com.david.smarthome&apos; &#125; &#125;&#125; 2、Android Studio会自动根据build.gradle 生成对应的BuildVariants。 对应Release与Debug即可组合成2*2 个版本的包。使用图形界面安装时可以通过Build Variants选择当前要build到手机的版本 3、Signed Apk时同样有2*2种维度的不同版本可供打包 自此我们已经完成多包名打包的配置 三、由于Android Studio 打Debug包时默认使用 签名为Debug版本，即：debug.keystore,而当我们接入的第三方SDK如微信等要求提交Release版本的签名（release.jks）。这个时候最方便的方式便是让打Debug包的时候直接使用我们正式版的签名 修改app.gradle,添加signingConfigs，同时在debug中指向该签名文件12345678910111213141516171819android &#123; signingConfigs &#123; signconfig &#123; keyAlias &apos;smarthome&apos; keyPassword &apos;123123&apos; storeFile file(&apos;/Users/david/AndroidStudioProjects/SmartHome/smarthome.jks&apos;) storePassword &apos;123123 &#125; &#125; debug &#123; ... signingConfig signingConfigs.signconfig &#125;&#125; ``` 以上两部即可实现我们的效果，Debug包已经使用的是我们正式版的签名文件 &gt; #### 四、定义打包命名规则，结合时间日期，免去手动重命名易错，没规律的问题 def releaseTime() { return new Date().format(“yyyy-MM-dd”, TimeZone.getTimeZone(“UTC”))}android{ applicationVariants.all { variant -&gt; if (variant.buildType.name.equals(‘release’)) { variant.outputs.all { output -&gt; def buildName = “com.david.smarthome” def type = variant.buildType.name def releaseApkName = buildName + ‘‘ + type + ““ + versionName + ‘‘ + releaseTime() + ‘.apk’ outputFileName = releaseApkName } } else { variant.outputs.all { output -&gt; def buildName = “com.david.smarthome” def releaseApkName = buildName + ‘‘ + “test” + ““ + versionName + ‘‘ + releaseTime() + ‘.apk’ outputFileName = releaseApkName } } }}```","categories":[{"name":"Android","slug":"Android","permalink":"http://hwzhang.top/categories/Android/"}],"tags":[{"name":"gradle","slug":"gradle","permalink":"http://hwzhang.top/tags/gradle/"}]},{"title":"RecyclerView系列之一：基础使用介绍","slug":"RecyclerView系列之一：基础使用介绍","date":"2017-03-22T08:58:51.000Z","updated":"2017-03-28T09:58:45.000Z","comments":true,"path":"2017/03/22/RecyclerView系列之一：基础使用介绍/","link":"","permalink":"http://hwzhang.top/2017/03/22/RecyclerView系列之一：基础使用介绍/","excerpt":"","text":"概述 关于RecyclerView，官方介绍：A flexible view for providing a limited window into a large data set. RecyclerView是一种能够利用有限窗口展现大型数据集的灵活视图。 同ListView类似，它具有自动回收ItemView的特性。但是相比ListView，RecyclerView到底有了哪些有点呢？ 本系列文章将从RecyclerView的使用，RecyclerView.Adapter的封装，源码分析等多个部分来让大家较深入的了解这个强大的控件本RecyclerView系列初步规划内容大致如下，源码托管在github上： 基础使用介绍(结合CardView) item刷新动画、item view点击监听 多布局使用 adapter封装 下拉刷新，上拉加载 Item侧滑删除，置顶，长按拖拽Item 加载中界面 RecyclerView源码分析 本节主要介绍RecyclerView的基本使用，内容主要包括3点： RecyclerView的引入，结合CardView LayoutManager 配置，Item的3种布局方式，横向、竖向以及瀑布流方式。 RecyclerView.Adapter 介绍 1、RecyclerView，CardView引入：123//compile版本对照 build.gradle 中的 targetSdkVersioncompile 'com.android.support:recyclerview-v7:25.0.1' compile 'com.android.support:cardview-v7:25.0.1' 2、先创建布局文件RecyclerView布局如下：123456789101112//activity_demo.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;android.support.v7.widget.RecyclerView android:id=&quot;@+id/recyclerView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;/android.support.v7.widget.RecyclerView&gt;&lt;/LinearLayout&gt; CardView布局如下：1234567891011121314151617181920212223242526272829303132333435363738394041//item_tv_list.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;vertical&quot;&gt; &lt;android.support.v7.widget.CardView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:clickable=&quot;true&quot; //可点击 android:layout_margin=&quot;10dp&quot; android:foreground=&quot;?android:attr/selectableItemBackground&quot;//点击效果，不适用cardView的话 可以在item父布局中添加shape来实现 app:cardCornerRadius=&quot;@dimen/cardview_radius&quot; app:contentPadding=&quot;10dp&quot; app:cardElevation=&quot;@dimen/cardview_elevation&quot;&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;vertical&quot;&gt; &lt;ImageView android:id=&quot;@+id/iv_pic&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;180dp&quot; android:scaleType=&quot;centerCrop&quot; android:src=&quot;@drawable/abc1&quot; /&gt; &lt;TextView android:id=&quot;@+id/tv_content&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:padding=&quot;5dp&quot; android:text=&quot;@string/op_subtext&quot; /&gt; &lt;/LinearLayout&gt; &lt;/android.support.v7.widget.CardView&gt;&lt;/LinearLayout&gt; CardView 属性说明1234567891011card_view:cardElevation 阴影的大小card_view:cardMaxElevation 阴影最大值card_view:cardBackgroundCollor 卡片的背景色card_view:cardCornerRadius 卡片的圆角大小card_view:contentPadding 卡片内容与边距的间隔card_view:contentPaddingBottom 卡片内容与底部的间隔card_view:contentPaddingTop 卡片内容与顶部的间隔card_view:contentPaddingLeft 卡片内容与左边的间隔card_view:contentPaddingRight 卡片内容与右边的间隔card_view:contentPaddingStartcard_view:contentPaddingEnd 3、初始化Activity、创建RecycleView.Adapter12345678//DemoActivity.java LinearLayoutManager linearLayout = new LinearLayoutManager(this);//横向 //linearLayout.setOrientation(LinearLayoutManager.HORIZONTAL);linearLayout.setOrientation(LinearLayoutManager.VERTICAL);ListAdapter adapter = new ListAdapter(this, initData());recyclerView.setLayoutManager(linearLayout);recyclerView.setAdapter(adapter); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.david.xrecyclerview.adapter;import android.content.Context;import android.support.v7.widget.RecyclerView;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.ImageView;import android.widget.TextView;import com.bumptech.glide.Glide;import com.david.xrecyclerview.R;import com.david.xrecyclerview.entity.DemoBean;import java.util.List;/** * Created by david on 17/3/28. */public class ListAdapter extends RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt; &#123; private Context context; private List&lt;DemoBean&gt; data; public ListAdapter(Context context, List&lt;DemoBean&gt; data) &#123; this.context = context; this.data = data; &#125; //绑定布局，注意返回值是viewHolder 而非view @Override public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View view = LayoutInflater.from(context).inflate(R.layout.item_rv_list, parent, false); return new ItemViewHolder(view); &#125; //赋值操作 @Override public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) &#123; Glide.with(context).load(data.get(position).getImageId()).into(((ItemViewHolder) holder).iv_pic); ((ItemViewHolder) holder).tv_content.setText(data.get(position).getContent()); &#125; //item 个数 @Override public int getItemCount() &#123; return data == null ? 0 : data.size(); &#125; //类似ListView中的ViewHolder，只不过在RecyclerView中强制实现 class ItemViewHolder extends RecyclerView.ViewHolder &#123; private ImageView iv_pic; private TextView tv_content; public ItemViewHolder(View itemView) &#123; super(itemView); iv_pic = (ImageView) itemView.findViewById(R.id.iv_pic); tv_content = (TextView) itemView.findViewById(R.id.tv_content); &#125; &#125;&#125; 到此我们已经成功的配合CardView，实现了最简单的使用","categories":[],"tags":[{"name":"android-widget-study","slug":"android-widget-study","permalink":"http://hwzhang.top/tags/android-widget-study/"}]},{"title":"Android Studio之NDK环境搭建，so文件打包以及使用","slug":"android-ndk-base","date":"2017-03-21T14:12:33.000Z","updated":"2017-03-22T04:01:31.000Z","comments":true,"path":"2017/03/21/android-ndk-base/","link":"","permalink":"http://hwzhang.top/2017/03/21/android-ndk-base/","excerpt":"","text":"关于ndk，jni的介绍请自行谷歌、百度。推荐查看网友的ndk系列文章，写的较为详细，深入Android NDK开发（该系列教程开发环境为win + Eclipse） 本篇入门教程开发环境为mac + Android Studio + gradle 2.14.1，主要包含以下3块内容： NDK环境搭建 编写第一个JNI项目 打包出动态so文件，在其他项目中使用 一、NDK环境搭建 从Android Studio安装(自行翻墙)打开AndroidStudio，选择顶部工具条，Tools-&gt;Android-&gt;SDK Manager-&gt;SDK Tools-&gt;NDK 点击install 自行下载ndk包1）国内推荐通过AndroidDevTools镜像下载，或者Google的官方网站下载Android NDK的安装包https://developer.android.com/ndk/downloads/index.html 2）下载ndk包后解析到某个路径，打开Project Structure-&gt;设置 NDK location ndk环境变量配置，我们需要使用到ndk-build命令 打开终端 -&gt; 输入 ：vim ~/.bash_profile -&gt; 加入ndk 包的路径(mac中环境变量之间以封号隔开) 自此，ndk开发环境我们已经可以进行jni开发了 二、JNI开发 创建android项目 查看项目local.properties中加入ndk和sdk的路径是否正确 12ndk.dir=/Users/userName/AndroidStudioProjects/ndk/android-ndk-r13bsdk.dir=/Users/userName/Library/Android/sdk 配置项目下的gradle.properties文件，表示我们要使用NDK进行开发。 1android.useDeprecatedNdk=true 在moudle根目录下的的build.gradle中的defaultConfig标签内部里加入如下代码 12345ndk&#123; moduleName &quot;hello&quot; //生成的so文件名字，调用C程序的代码中会用到该名字 abiFilters &quot;armeabi&quot;, &quot;armeabi-v7a&quot;, &quot;x86&quot; //输出指定三种平台下的so库, // 还可以添加 &apos;x86_64&apos;, &apos;mips&apos;, &apos;mips64&apos;&#125; 编写jni代码 1234567891011121314151617181920package com.david.ndktest;-public class MainActivity extends AppCompatActivity &#123; //使用静态代码块，表示我们要加载的资源文件为libsecret.so static &#123; System.loadLibrary(&quot;secret&quot;); &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); TextView tv_msg = (TextView) findViewById(R.id.tv_msg); tv_msg.setText(stringFromat()); &#125; //声明一个本地方法，用native关键字修饰 public native String stringFromat();&#125; 生成.h头文件直接使用Android Studio 底部的Terminal，默认命令行窗口路径已经在当前项目，进入到app/src/main/java目录，输入以下命令（固定格式：javah -jni 包名+类名） 1javah -jni com.david.ndktest.MainActivity 为在对应包的根目录下生成.h文件，熟悉该函数名后，日常开发中可以不用生成.h文件 执行第5部的时候，对应native会提示找不到对应方法，快捷键 alt+enter 会生成对应jni文件夹，包含libName.c文件，此处MainActivity中的native方法还是会显示红色，但是不影响编译 编译项目后会发现app/build中已经生成so文件，并且已经对应的cpu包就是我们在gradle中已经配置的,并且已经调用成功 自此我们的第一个JNI项目已经编写完毕 三、打包出动态so文件，在其他项目中使用 有时候我们的需求是这样的，我们把一些比较重要的业务逻辑封装到ndk内部，对java层只暴露接口。我们就需要打包出so文件，并且可能需要在其他项目中使用，下面将介绍so（符合JNI标准）文件的打包，以及在其他项目中如何正确的调用 编写Android.mk文件，放到jni文件夹根目录，与.c文件同级 1234567LOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE := secret //lib 名LOCAL_SRC_FILES := \\ /Users/userName/AndroidStudioProjects/NdkTest/app/src/main/jni/secret.c \\ //.c文件名include $(BUILD_SHARED_LIBRARY) 使用ndk-build命令（需要配置ndk环境变量，参照第一步第3点），生成so文件 进入到main目录后在terminal中输入命令，ndk-build工具便会帮我们打包出所有cpu平台so文件（目前不知道如何设置需要打包cpu平台） 1ndk-build 其他项目中使用该so文件 拷贝so文件到项目的main/jniLibs目录 ==新建package，包名与类名以及方法名必须与生成so文件的类保持一致！== 使用方法与第二部一致，需要声明loadLibrary与native方法 调用native方法123456789101112com.keywea.duolintest;-public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); TextView tv_msg = (TextView) findViewById(R.id.tv_msg); tv_msg.setText(com.david.ndktest.MainActivity.stringFromat()); &#125;&#125; 自此我们已经能够接入符合JNI标准的so库，重点在于包名，类名，方法名需要与so库保持一致，因此我们在提供so库的时候一定要记录详细的交互文档","categories":[{"name":"Android","slug":"Android","permalink":"http://hwzhang.top/categories/Android/"}],"tags":[{"name":"NDK、JNI","slug":"NDK、JNI","permalink":"http://hwzhang.top/tags/NDK、JNI/"}]},{"title":"greenDAO3 入门（配置，基本操作，数据库升级）","slug":"sqlite-greendao3","date":"2017-03-21T13:13:43.000Z","updated":"2017-03-22T04:01:37.000Z","comments":true,"path":"2017/03/21/sqlite-greendao3/","link":"","permalink":"http://hwzhang.top/2017/03/21/sqlite-greendao3/","excerpt":"","text":"Sqlite作为android重要的数据存储库，原生类SQLiteOpenHelper使用起来繁琐容易出错，本着”偷懒”的目的，来学习一下当下十分受欢迎的ORM 框架： greenDAO；网上教程不少，但是大都是针对3.0之前的版本，greenDAO2和3的构建和生成代码的方式区别很大，最终还是通过greenDAO github上的介绍，慢慢摸索，成功的在项目中构建了greenDAO，本文章写于greenDao更新至3.2版本一、什么是greenDAO？官方介绍：greenDAO githubgreenDAO 官网网友的博客：Android ORM框架 GreenDao3.0的使用 greenDAO3开始使用注解的方式定义实体类（entity），并且是通过安装gradle插件来生成代码。 二、如何使用greenDAO构建之前，不熟悉gradle概念的同学建议学习Gradle for android 系列教程 先来看下greenDAO 官方构建介绍： 开始搭建： github中提示添加maven仓库，但是android studio 项目已经默认包含了jcenter仓库，而jcenter仓库就是maven仓库的一个分支，因此我们不要再添加仓库，直接添加classPath即可 在moudle下的build.gradle文件中 申明插件以及配置greendao（可以不配置） 并在dependencies中添加compile12/* green dao */compile 'org.greenrobot:greendao:3.2.0 三、使用greenDAO 编写实体类:User类，使用greendao @Entity注解 12345678910import org.greenrobot.greendao.annotation.Entity;import org.greenrobot.greendao.annotation.Id;@Entitypublic class User &#123; @Id private long id; private String userName; private int age; private String gender;&#125; 编译项目，build后greendao插件会为所有带有该注解的实体生成Dao文件，以及DaoManager与DaoSession，默认生成目录为build/generated/source ,如果我们在gradle脚本中配置了，则会生成在我们的配置目录 不配置，则在默认目录(build/generated/source/greendao)下生成dao文件: 四、greenDAO 注解1234567891011121314151617181920211.实体@Entity注解schema：告知GreenDao当前实体属于哪个schemaactive：标记一个实体处于活动状态，活动实体有更新、删除和刷新方法nameInDb：在数据中使用的别名，默认使用的是实体的类名indexes：定义索引，可以跨越多个列createInDb：标记创建数据库表2.基础属性注解@Id :主键 Long型，可以通过@Id(autoincrement = true)设置自增长@Property：设置一个非默认关系映射所对应的列名，默认是的使用字段名 举例：@Property (nameInDb=\"name\")@NotNul：设置数据库表当前列不能为空@Transient ：添加次标记之后不会生成数据库表的列3.索引注解@Index：使用@Index作为一个属性来创建一个索引，通过name设置索引别名，也可以通过unique给索引添加约束@Unique：向数据库列添加了一个唯一的约束4.关系注解@ToOne：定义与另一个实体（一个实体对象）的关系@ToMany：定义与多个实体对象的关系 五、使用greenDAO 进行数据操作（详情可查阅博友的文章） 使用单例模式构建一个工具类来获取daoSession等对象12345678910111213141516171819202122232425262728293031public class GreenDaoHelper &#123; private static DaoMaster.DevOpenHelper devOpenHelper; private static SQLiteDatabase database; private static DaoMaster daoMaster; private static DaoSession daoSession; /** * 初始化greenDao * 建议放在Application 中进行 */ public static void initDatabase()&#123; // 通过 DaoMaster 的内部类 DevOpenHelper，你可以得到一个便利的 SQLiteOpenHelper 对象。 // 可能你已经注意到了，你并不需要去编写「CREATE TABLE」这样的 SQL 语句，因为 greenDAO 已经帮你做了。 // 注意：默认的 DaoMaster.DevOpenHelper 会在数据库升级时，删除所有的表，意味着这将导致数据的丢失。 // 所以，在正式的项目中，你还应该做一层封装，来实现数据库的安全升级。 devOpenHelper = new DaoMaster.DevOpenHelper(AppContext.getInstance(),\"cache-db\",null);//数据库名 database = devOpenHelper.getWritableDatabase(); // 注意：该数据库连接属于 DaoMaster，所以多个 Session 指的是相同的数据库连接。 daoMaster = new DaoMaster(database); daoSession = daoMaster.newSession(); &#125; public static DaoSession getDaoSession() &#123; return daoSession; &#125; public static SQLiteDatabase getDb() &#123; return database; &#125;&#125; 数据库的增删改查我们都将通过Dao来操作 增加数据(直接inser一个对象即可，十分简便)123456private UserDao mUserDao = GreenDaoHelper.getDaoSession().getUserDao(); public void insertData()&#123; //数据库的增删改查我们都将通过UserDao来进行，插入操作如下： mUserDao.insert(new User(null,\"david\",23,\"male\"));//id传null 即自增。==&gt; 这里是Long类型而不是long &#125; 小手一抖，一口气插了6条数据: 删除数据(删除数据和修改数据的思路一样，都是要先查找到数据)，操作很简单，效果就不一一截图了 1234//查询id等于3的所有行并删除User user = mUserDao.queryBuilder().where(UserDao.Properties.Id.eq(3)).build().unique();if (user == null) ToastUtils.show(getView(), \"用户不存在!\");else mUserDao.deleteByKey(user.getId()); 12345//查询id小于5的集合并删除List&lt;User&gt; userList = (List&lt;User&gt;) mUserDao.queryBuilder().where(UserDao.Properties.Id.le(5)).build().list();for (User user : userList) &#123; mUserDao.delete(user);&#125; 12//删除所有数据mUserDao.deleteAll(); 修改数据123//修改id为2的行 User user = new User((long) 2, \"Nancy\", 23, \"female\");mUserDao.update(user); 123456789//查询id&gt;= 3 且like (\"%david%\")User user = mUserDao.queryBuilder() .where(UserDao.Properties.Id.ge(3), UserDao.Properties.UserName.like(\"%david%\")).build().unique();if (user == null) &#123; ToastUtils.show(getView(), \"用户不存在!\");&#125; else &#123; user.setUserName(\"王五\"); mUserDao.update(user);&#125; 查询数据 123456//查出所有数据List&lt;User&gt; users = mUserDao.loadAll(); //查询id为1~4之间的数，查出前2个List&lt;User&gt; users = mUserDao.queryBuilder() .where(UserDao.Properties.Id.between(1, 4)).limit(2).build().list(); 六、数据库升级数据库升级的意义：如果我们再项目中使用了数据库。而数据库的结构在第一版的时候定下来，之后发布功能更新，或增加业务逻辑，原来的数据库结构可能就不适用了。而如果数据库的结构与之前版本的结构不同，新版本的应用读取旧数据库肯定会出问题。解决办法只有两种：1.让用户卸载老版本再安装新的程序；2.软件自行更新数据库结构。第一种办法很明显不具备可操作性，而且用户一旦卸载软件，数据就丢失了，这是不能容忍的事情。因此，作为开发者必须妥善处理数据库的升级问题。 修改gradle文件 首先在module的gradle文件中修改版本号： 12//改为最新的版本号 schemaVersion 2 如果只是做了上面的步骤则会默认清除所有数据,一看源码便知，当检测到version变化的时候便执行dropAllTables()操作，再重新建库1234567891011121314151617/** WARNING: Drops all table on Upgrade! Use only during development. */public static class DevOpenHelper extends OpenHelper &#123; public DevOpenHelper(Context context, String name) &#123; super(context, name); &#125; public DevOpenHelper(Context context, String name, CursorFactory factory) &#123; super(context, name, factory); &#125; @Override public void onUpgrade(Database db, int oldVersion, int newVersion) &#123; Log.i(\"greenDAO\", \"Upgrading schema from version \" + oldVersion + \" to \" + newVersion + \" by dropping all tables\"); dropAllTables(db, true); onCreate(db); &#125;&#125; 数据迁移的核心思想：1 把旧表改为临时表2 建立新表3 临时表数据写入新表，删除临时表 站在巨人的肩膀上，这里直接使用了开源的库，配合greenDAO来做数据迁移，亲测稳定：GreenDaoUpgradeHelper schemaVersion 版本加1，User类新增属性：major 不做迁移处理前，重新安装后数据库已经被重置，数据为空。迁移配置后，旧表数据已经被存到新表中，major字段为null; 使用方式该git上面介绍的很详细了，不再赘述。感谢前辈们的无私分享。","categories":[{"name":"Android","slug":"Android","permalink":"http://hwzhang.top/categories/Android/"}],"tags":[{"name":"sqlite","slug":"sqlite","permalink":"http://hwzhang.top/tags/sqlite/"}]},{"title":"android studio 下使用SlidingMenu侧滑菜单","slug":"SlidingMenu","date":"2017-03-21T12:47:00.000Z","updated":"2017-03-22T04:01:12.000Z","comments":true,"path":"2017/03/21/SlidingMenu/","link":"","permalink":"http://hwzhang.top/2017/03/21/SlidingMenu/","excerpt":"","text":"项目中需要使用到侧滑菜单，由于一直有点抵触使用第三方库，因为大部分库为了兼容各种需求，封装得大都比较笨重，所以就在网上找有没有自己写的自定义侧滑菜单，还真被我找到了史上最简单粗暴实现侧滑菜单 ，使用这个自定义的SlideMenu确实很轻松的给项目集成了侧滑菜单，然后却存在一些问题，比如我的主页中用到viewpager来实现广告控件，当我拉出侧滑菜单时，由于主页广告bannerView自动切换，我猜想是否是由于焦点问题，这样导致侧滑菜单自动执行了menu.close()操作，体验实在太差 ，不能忍。一开始的解决办法是当侧滑菜单滑出时，暂停bannerView自动切换，虽然有点取巧，但还是解决了那个问题。但是经理要求带滑出动画，以及淡入淡出的效果。时间紧迫，想想还是先把它放下，研究了一下大名鼎鼎的侧滑菜单：SlidingMenu框架 接入过程还是碰到了一些小问题，花了些时间，就此简单记录一下1、 查了下github，该项目好像不支持compile 方式从maven仓库添加，那就从github上面clone下项目,找到library项目2、 打开项目配置：Project Structure –&gt; 左上角加号 –&gt; import gradle project –&gt; 找到对应library（最好改名为slidingMenu，以便一眼可以看出该库）3、 同样在Project Structure中添加Depenencies,添加对该项目的引用，或者可以通过moudle下的gradle文件中加入: 1compile project(&apos;:slidingMenu&apos;) 4、 修改slidingMenu gradle文件，大致如下，sdk版本按主项目修改： 如上算是把library成功导入了主项目，接着开始使用slidingMenu activity_main.xml布局如下：(slidingMenu里面包含项目主页，左侧菜单栏不放入其中) 1234567 &lt;com.jeremyfeinstein.slidingmenu.lib.SlidingMenu xmlns:sliding=&quot;http://schemas.android.com/apk/res-auto&quot; android:id=&quot;@+id/slidingMenu&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;fill_parent&quot;&gt; &lt;include layout=&quot;@layout/activity_main&quot; /&gt;&lt;/com.jeremyfeinstein.slidingmenu.lib.SlidingMenu&gt; MainActivity.java 12345678910111213@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); slidingMenu = new SlidingMenu(this);//创建对象 slidingMenu.setMode(SlidingMenu.LEFT);//设定模式，SlidingMenu在左边 slidingMenu.setBehindOffsetRes(R.dimen.sliding_menu_offset);//配置slidingmenu偏移出来的尺寸 slidingMenu.setTouchModeAbove(SlidingMenu.TOUCHMODE_FULLSCREEN);//全屏都可以拖拽触摸，打开slidingmenu slidingMenu.attachToActivity(this,SlidingMenu.SLIDING_CONTENT);//附加到当前的activity上去 leftView = inflate(this, R.layout.drawable_tab, null); slidingMenu.setMenu(leftView);//也可以直接跟layout id&#125; menu开关操作 123menu.toggle();// 动态判断自动关闭或开启SlidingMenu menu.showContent();// 显示内容menu.showMenu();// 显示SlidingMenu 大部分情况下还是需要对左侧菜单栏布局进行操作的，监听的话就通过上面的leftView来查找指定的view。 menu开关监听 123456789101112// 监听menu打开 menu.setOnOpenedListener(new OnOpenedListener() &#123; @Override public void onOpened() &#123; &#125; &#125;); // 监听menu关闭 menu.setOnClosedListener(new OnClosedListener() &#123; @Override public void onClosed() &#123; &#125; &#125;); 自此已经将slidingMenu接入项目并且使用起来，后续需要找时间研究一下源码","categories":[{"name":"Android","slug":"Android","permalink":"http://hwzhang.top/categories/Android/"}],"tags":[{"name":"android第三方接入","slug":"android第三方接入","permalink":"http://hwzhang.top/tags/android第三方接入/"}]},{"title":"RecyclerView 多布局，Item中使用EditText刷新问题扫坑","slug":"RecyclerView-multiple-item-type","date":"2017-03-21T09:54:39.000Z","updated":"2017-03-22T04:01:06.000Z","comments":true,"path":"2017/03/21/RecyclerView-multiple-item-type/","link":"","permalink":"http://hwzhang.top/2017/03/21/RecyclerView-multiple-item-type/","excerpt":"","text":"项目中需要用到一个高度动态的布局用于录入用户信息，信息类型以及参数字段等全来自后台。因此需要用RecyclerView来动态显示，同时使用Item多布局来对应不同类型的信息录入（log：提前已知所有可能输入的类型），这里记录一下自己的解决方式，以及item中使用EditText碰到的问题（欢迎吐槽，互相交流） 先来看下需要实现的界面效果 这里可以看到尾巴上一步，下一步布局也通过占用一个item的方式来实现footerView的效果，从图中可以直观的看出当前页面一共有3种布局，其中item_type_1中用到了EditText，item_type_2中使用TextView来展示地址选择结果，item_type_3使用两个TextView来制作按钮。 一、RecyclerView多布局的使用没错，还是老套路，重点一定在Adapter，并且这里会使用到getItemViewType（）方法来指定待显示的item布局。这里为了简单明了，直接使用未封装的 RecyclerView.Adapter。重要代码如下： 123456//一共5种布局private static final int TYPE_EDITTEXT = 1;//editText布局private static final int TYPE_EDITADDRESS = 2;//地址选择器布局private static final int TYPE_GETCODE = 3;//动态获取数据（信息选择器）private static final int TYPE_EDITIDCARD = 4;//身份信息提交布局private static final int TYPE_FOOTERVIEW = 5;//底部下一步 布局 12345678910111213//通过重写getItemViewType(int position)方法来告诉onCreateViewHolder(...)每个条目对应的布局 @Overridepublic int getItemViewType(int position) &#123; switch (fieldsList.get(position).getInput_type()) &#123; case 1: return TYPE_EDITTEXT; case 2: return TYPE_EDITADDRESS; case ... &#125; return TYPE_FOOTERVIEW;&#125; 1234567891011121314151617181920//返回不同布局对应的ViewHolder @Override public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; switch (viewType) &#123; case TYPE_EDITTEXT: return new EditTextItemHolder(LayoutInflater.from(context).inflate(R.layout.item_rv_type_edittext, parent, false)); case TYPE_EDITADDRESS: return new EditAddRessItemHolder(LayoutInflater.from(context).inflate(R.layout.item_rv_type_editaddress, parent, false)); case ... &#125; return new FooterViewHolder(LayoutInflater.from(context).inflate(R.layout.item_rv_type_footview, parent, false)); &#125; //当然，每种item都需要有自己的ViewHolderclass EditIDCardItemHolder extends RecyclerView.ViewHolder &#123; public EditIDCardItemHolder(View itemView) &#123; super(itemView); &#125;&#125; 123456789//onBindViewHolder()中绑定数据 也需要知道当前布局属于哪个item @Override public void onBindViewHolder(RecyclerView.ViewHolder holder, final int position) &#123; final FieldInfoBean bean = fieldsList.get(position); if (holder instanceof EditTextItemHolder) &#123; ... &#125; &#125; 是不是发现RecyclerView的多布局实现其实也是十分简单呢。 二、RecyclerView中使用EditText网上看到博友在ListView中使用EditText时，点击editText后软键盘弹出后会导致光标失去焦点，这里我在使用RecyclerView的时候并没有发现光标问题，这里先跳过光标问题。 使用EditText是主要问题在于如何获取到EditText的值，以及刷新adapter时，出现editText值错乱12345678910111213141516171819202122//可能是由于RecyclerView的回收，无法使用getView（）.getText()来获取EditText的值//很多博友也是使用了addTextChangedListener（watcher()）的方式来获取用户输入的值，并且需要及时的保存数据 TextWatcher watcher = new TextWatcher() &#123; @Override public void beforeTextChanged(CharSequence charSequence, int i, int i1, int i2) &#123; &#125; @Override public void onTextChanged(CharSequence charSequence, int i, int i1, int i2) &#123; &#125; @Override public void afterTextChanged(Editable editable) &#123; if (TextUtils.isEmpty(editable.toString())) &#123; bean.setValue(&quot;&quot;); &#125; else &#123; bean.setValue(editable.toString()); &#125; &#125; &#125;; ((EditTextItemHolder)holder).et_text.addTextChangedListener(watcher); 上述操作方式其实给自己埋了一个坑，仅仅操作EditText时并没有什么反常，而当我需要调用Adapter的刷新方法时候一个大坑等着我们…常用的刷新方式有以下两种： 12adapter.notifyItemChanged(pos);//仅刷新单个itemadapter.notifyDataSetChanged();//刷新整个adapter 否则选中省信息后，市信息不能回归默认 得益于RecyclerView的优化，相比于ListView增加了单个item刷新操作，所以在项目中当我仅需刷新单个item时并没有异常，textWatcher 工作的很正常 当我使用多级联动时候，由于每一级分处不同的item，所以我不得不调用第二种方式去刷新整个item（虽然我也可以多次调用第一种方式，这里讨论必须全部刷新的情况下），刷新完之后发现zheng’ge整个List 混乱了，数据错乱，而我发现仅仅是使用了EditText的地方出错，并且是在使用了TextWatcher的item，似乎找到了问题的根源… 于是，果断开启debug模式，最终确认确实是TextWatcher的问题，由于调用了notifyDataSetChanged（）方法，而导致EditText重绘，并且每次都走了textWatcher的afterTextChanged（）方法，于是网上查了资料，最终顺利解决了问题。记录如下：123456789101112131415161718192021222324252627282930313233//完整代码 if (holder instanceof EditTextItemHolder) &#123; //1、为了避免TextWatcher在第2步被调用，提前将他移除。 if (((EditTextItemHolder) holder).et_text.getTag() instanceof TextWatcher) &#123; ((EditTextItemHolder) holder).et_text.removeTextChangedListener((TextWatcher) (((EditTextItemHolder) holder).et_text.getTag())); &#125; // 第2步：移除TextWatcher之后，设置EditText的Text。 ((EditTextItemHolder) holder).et_text.setText(bean.getValue()); TextWatcher watcher = new TextWatcher() &#123; @Override public void beforeTextChanged(CharSequence charSequence, int i, int i1, int i2) &#123; &#125; @Override public void onTextChanged(CharSequence charSequence, int i, int i1, int i2) &#123; &#125; @Override public void afterTextChanged(Editable editable) &#123; if (TextUtils.isEmpty(editable.toString())) &#123; bean.setValue(&quot;&quot;); &#125; else &#123; bean.setValue(editable.toString()); &#125; &#125; &#125;; ((EditTextItemHolder) holder).et_text.addTextChangedListener(watcher); ((EditTextItemHolder) holder).et_text.setTag(watcher); &#125; 自此也算顺利解决了这个问题，博友们有好的实现方式还请分享【笑脸】","categories":[{"name":"Android","slug":"Android","permalink":"http://hwzhang.top/categories/Android/"}],"tags":[{"name":"android-widget-study","slug":"android-widget-study","permalink":"http://hwzhang.top/tags/android-widget-study/"}]},{"title":"android Wifi 相关","slug":"wifi-dev","date":"2016-09-13T15:05:02.000Z","updated":"2017-03-22T04:00:29.000Z","comments":true,"path":"2016/09/13/wifi-dev/","link":"","permalink":"http://hwzhang.top/2016/09/13/wifi-dev/","excerpt":"","text":"眼看自己来这个公司的第一个项目，也是公司的核心项目即将上线了，细数一番，已有半年之久，中间也做了一些小项目，忍不住惊叹了一下，这么久了居然没有做下笔记，真是罪过罪过。记得学习android之时就喜欢记下开发知识点，开发技巧。在我看来，总结可以使自己稳步进步。趁项目稍微空余时期，总结一下，涉及到WIFI开发相关的东西相当之多，这里主要记录一下项目中用到的相关知识。【感谢博友的资料http://smallwoniu.blog.51cto.com/3911954/1334951】 主要类与接口 WifiManagerwifi连接统一管理类，获取WIFI网卡的状态(WIFI网卡的状态是由一系列的整形常量来表示的) ScanResult 主要用来描述已经检测出的接入点，包括接入点的地址，接入点的名称，身份认证，频率，信号强度等信息。其实就是通过wifi 硬件的扫描来获取一些周边的wifi 热点的信息。 WifiConfigurationWifi网络的配置，包括安全设置等，在我们连通一个wifi 接入点的时候，需要获取到的一些信息。主要包含四个属性： BSSID：BSS是一种特殊的Ad-hoc LAN(一种支持点对点访问的无线网络应用模式)的应用，一个无线网络至少由一个连接到有线网络的AP和若干无线工作站组成，这种配置称为一个基本服务装置。一群计算机设定相同的 BSS名称，即可自成一个group，而此BSS名称，即所谓BSSID。通常，手机WLAN中，bssid其实就是无线路由的MAC地址。 networkid：网络ID。 PreSharedKey：无线网络的安全认证模式。 SSID：SSID(Service SetIdentif)用于标识无线局域网，SSID不同的无线网络是无法进行互访的。 WifiInfowifi无线连接的描述，包括（接入点，网络连接状态，隐藏的接入点，IP地址，连接速度，MAC地址，网络ID，信号强度等信息）。这里简单介绍一下WifiManager中常用的方法: 方法名 注释 getSSID() 获得SSID（热点名称） getBSSID() 获取BSSID getDetailedStateOf() 获取客户端的连通性 getHiddenSSID() 获得SSID 是否被隐藏 getIpAddress() 获取IP 地址 getLinkSpeed() 获得连接的速度(我测试时发现没什么卵用- -) getMacAddress() 获得Mac 地址 getRssi() 获得802.11n 网络的信号 在AndroidManifest.xml进行对WIFI操作的权限设置12345&lt;!-- 以下是使用wifi访问网络所需的权限 --&gt; &lt;uses-permission android:name=\"android.permission.CHANGE_NETWORK_STATE\"&gt;&lt;/uses-permission&gt; &lt;uses-permission android:name=\"android.permission.CHANGE_WIFI_STATE\"&gt;&lt;/uses-permission&gt; &lt;uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\"&gt;&lt;/uses-permission&gt; &lt;uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\"&gt;&lt;/uses-permission&gt; 使用方法 WIFI开发 我想第一点首先是如何打开wifi开关打开之前先获取WifiManager 对象，通过该对象的isWifiEnabled():boolean 方法来获取当前wifi的开启情况，如果未打开，则执行打开wifi开关操作 1234WifiManager mWifiManager = (WifiManager) context.getSystemService(Context.WIFI_SERVICE);if (！mWifiManager.isWifiEnabled()) &#123;//wifi未打开 执行打开操作 mWifiManager.setWifiEnabled(true);//同样的执行关闭操作的话： mWifiManager.setWifiEnabled(false);&#125; WIFI打开之后自然是执行扫描操作，搜索周边范围内的热点信息123456789101112131415161718192021/** * 扫描热点,扫描时耗时操作，如果界面中需要展示进度条的话，建议将扫描操作放在子线程中操作 */ mWifiManager.startScan(); // 得到扫描结果 List&lt;ScanResult&gt; mWifiList = mWifiManager.getScanResults(); // 得到配置好的网络连接,列表中可能出现重复的热点，并且可能是ssid为空的热点，根据需求情况 自行过滤 mWifiConfiguration = mWifiManager.getConfiguredNetworks(); // 查看扫描结果 public StringBuilder lookUpScan() &#123; StringBuilder stringBuilder = new StringBuilder(); for (int i = 0; i &lt; mWifiList.size(); i++) &#123; stringBuilder .append(\"Index_\" + new Integer(i + 1).toString() + \":\"); // 将ScanResult信息转换成一个字符串包 // 其中把包括：BSSID、SSID、capabilities、frequency、level stringBuilder.append((mWifiList.get(i)).toString()); stringBuilder.append(\"/n\"); &#125; return stringBuilder; &#125; 获取正在连接中的SSID12345mWifiInfo.getSSID()/** * 获得当前连接的热点 用上面方法 可能获得的结果为： \"0x\" 或 \"&lt;unknown ssid&gt;\" * 猜测是因为wifiInfo的问题，因此每次去getSSID（）的时候需要获得最新的wifiInfo对象 */ 如果需要的话 对热点信号强度进行排序1234567891011121314//将搜索到的wifi根据信号从强到弱进行排序 private List&lt;ScanResult&gt; sortByLevel(List&lt;ScanResult&gt; list) &#123; ScanResult temp = null; for (int i = 0; i &lt; list.size(); i++) for (int j = 0; j &lt; list.size(); j++) &#123; if (list.get(i).level &gt; list.get(j).level) //level属性即为强度 &#123; temp = list.get(i); list.set(i, list.get(j)); list.set(j, temp); &#125; &#125; return list; &#125; 连接到热点1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** * 众所周知 热点的加密分为三种情况：1没有密码 2用wep加密 3用wpa加密 */ public static WifiConfiguration CreateWifiInfo(String SSID, String Password, int Type) &#123; WifiConfiguration config = new WifiConfiguration(); config.allowedAuthAlgorithms.clear(); config.allowedGroupCiphers.clear(); config.allowedKeyManagement.clear(); config.allowedPairwiseCiphers.clear(); config.allowedProtocols.clear(); config.SSID = \"\\\"\" + SSID + \"\\\"\"; WifiConfiguration tempConfig = IsExsits(SSID); if (tempConfig != null) &#123; mWifiManager.removeNetwork(tempConfig.networkId); &#125; if (Type == 1) //WIFICIPHER_NOPASS &#123; /* config.wepKeys[0] = \"\";//连接无密码热点时加上这两句会出错 config.wepTxKeyIndex = 0;*/ config.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.NONE); &#125; if (Type == 2) //WIFICIPHER_WEP &#123; config.hiddenSSID = true; config.wepKeys[0] = \"\\\"\" + Password + \"\\\"\"; config.allowedAuthAlgorithms.set(WifiConfiguration.AuthAlgorithm.SHARED); config.allowedGroupCiphers.set(WifiConfiguration.GroupCipher.CCMP); config.allowedGroupCiphers.set(WifiConfiguration.GroupCipher.TKIP); config.allowedGroupCiphers.set(WifiConfiguration.GroupCipher.WEP40); config.allowedGroupCiphers.set(WifiConfiguration.GroupCipher.WEP104); config.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.NONE); config.wepTxKeyIndex = 0; &#125; if (Type == 3) //WIFICIPHER_WPA &#123; config.preSharedKey = \"\\\"\" + Password + \"\\\"\"; config.hiddenSSID = true; config.allowedAuthAlgorithms.set(WifiConfiguration.AuthAlgorithm.OPEN); config.allowedGroupCiphers.set(WifiConfiguration.GroupCipher.TKIP); config.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.WPA_PSK); config.allowedPairwiseCiphers.set(WifiConfiguration.PairwiseCipher.TKIP); //config.allowedProtocols.set(WifiConfiguration.Protocol.WPA); config.allowedGroupCiphers.set(WifiConfiguration.GroupCipher.CCMP); config.allowedPairwiseCiphers.set(WifiConfiguration.PairwiseCipher.CCMP); config.status = WifiConfiguration.Status.ENABLED; &#125; return config; &#125; // 添加一个网络并连接 public static boolean addNetwork(WifiConfiguration wcg) &#123; int wcgID = mWifiManager.addNetwork(wcg); boolean b = mWifiManager.enableNetwork(wcgID, true); System.out.println(\"a--\" + wcgID); System.out.println(\"b--\" + b); if (b) &#123; linkingID = wcgID; &#125; return b; &#125; //连接方式 WifiConfiguration wifiConfiguration = CreateWifiInfo(SSID, Password, Type); boolean flag = addNetwork(wifiConfiguration);//连接网络 /** *flag 返回true 并不能代表热点连接成功，但是返回false一定代表连接不成功 *当密码位数不对时也会直接返回false，因此不能用该参数来判别是否连接成功 *这也是我在项目中碰到的一个难题 */ 项目中涉及到wifi切换连接，这个时候就需要监听热点切换情况，这是个难点。不同设备的热点连接速度也不一致，我的做法是启动一个定时任务，当wifi进行切换时先保存oldCurrentSSID，gonaLinkSSID来保存目的连接SSID，然后定时的去读取当前连接中的ssid：mWifiInfo.getSSID(),来实时的监听当前热点情况，如果当前热点与oldCurrentSSID不等，并且等于gonaLinkSSID,即代表热点切换成功。这边需要考虑的是这个定时的长度，因为wifi没有正在连接的状态，所以这边无法准确知道何时连接完毕，所以这里只能给个大概的时间，同时在该时间内如果满足连接成功状态，即可提前取消定时刷新任务。同时需要结合广播（当网络状态变化时系统会发出一条广播）来得到最准确的值。 断开指定连接 // 断开指定ID的网络,这边的id在添加连接时获取 int wcgID = mWifiManager.addNetwork(wcg); public static void disconnectWifi(int netId) { if(0 == linkingID ){ return; } mWifiManager.disableNetwork(linkingID); mWifiManager.disconnect(); LogUti.i(\"info\", \"断开连接 id\" + linkingID); } //有些情况下我们可能并不方便拿到那个id，这个时候可以投机取巧的地方是随便连接一个不能连接成功的ssid，当ssid切换的时候 wifi会先自动断开当前连接的热点才去连接目标ssid","categories":[{"name":"Android","slug":"Android","permalink":"http://hwzhang.top/categories/Android/"}],"tags":[{"name":"android-unwidget-study","slug":"android-unwidget-study","permalink":"http://hwzhang.top/tags/android-unwidget-study/"}]},{"title":"关于Android接入微信支付","slug":"wxpay-notes","date":"2016-09-07T13:13:50.000Z","updated":"2017-03-22T04:00:59.000Z","comments":true,"path":"2016/09/07/wxpay-notes/","link":"","permalink":"http://hwzhang.top/2016/09/07/wxpay-notes/","excerpt":"","text":"前段时间开发一款产品，需要接入支付，老板对微信支付情有独钟。刚好自己没有实际做过微信支付这块，也就可以借这次机会实践一下，顺便记录一下自己的扫坑之路，主要记录步骤，具体细节直接微信开发平台上看，第三方的东西更新比较快，这里详细记录意义不大。 接入步骤如下1、申请账号，这个建议让公司去申请（注意看平台，微信支付分为好多种场景，本次介绍的是移动支付，到微信开方平台申请账号）2、申请应用 （微信支付在应用审核通过后，直接在该应用内申请）3、项目配置（借用一些官网的图） 首先下载 - libammsdk.jar （注意区分不同功能 jar包不同，有些项目单独做微信登录的jar包名跟这个一样，但是内容不一，如果项目中微信登录，分享，支付都用了，就下载指定的jar包，包含3种功能的库文件） （官方放的是Eclipse的图，AndroidStudio 也差不多） 导包，加入权限 我是直接在Application中注册微信APP_ID 新建包：包名下.wxapi ,微信比较霸道，包名写错了还不写，包名跟微信回调类名写错，即无法接收到微信客户端的本地回调信息= =！使用微信支付需要建WXPayEntryActivity 并且实现 IWXAPIEventHandler，而在 @Override public void onResp(BaseResp baseResp){} 方法中进行支付回调后的处理 核心部分先介绍下操作流程： 为了安全，我们建议将微信开放平台申请的AppSecret存放于服务器后台，同时将一些操作放在后台来处理， 同时也便于订单等信息的操作。 编写微支付回调类这里我是该类不给界面，并将该Activity主题弄成透明,回调之后通过中间配置文件来传递回调信息，并马上finish 该回调类，回到支付发起页面来进行剩余的逻辑处理（支付发起页面的onResume中来判断微信支付回调值得变化，进行操作后马上将该值重置，保证回调后的逻辑操作只进行一次而不会因为多次可能的onResume而导致执行多次） 1234567891011&lt;style name=&quot;Theme.Translucent.NoTitleBar&quot;&gt; &lt;item name=&quot;windowNoTitle&quot;&gt;true&lt;/item&gt; &lt;item name=&quot;windowContentOverlay&quot;&gt;@null&lt;/item&gt;&lt;/style&gt; &lt;activity android:name=&quot;.wxapi.WXPayEntryActivity&quot; android:exported=&quot;true&quot; android:launchMode=&quot;singleTop&quot; android:theme=&quot;@android:style/Theme.Translucent.NoTitleBar&quot; android:screenOrientation=&quot;portrait&quot; /&gt; 在本地调用微信支付之前我们需要先从服务端获取到预付订单信息，以及 sign先来看下调用微信客户端发起支付需要哪些参数： 这边碰到一个大坑：就是这个sign，当我们向服务端发起请求获取预付订单信息时，服务端需要向微信api请求数据，从而获取微信端生成的prepayid，最终才返回给移动端。 从微信支付官方文档中看到，发起预付订单（统一下单）请求时，就要求签名一次，因此这边后台开发人员很容易就直接将这个sign作为返回给移动端的sign，从而导致移动端无论如何都调用不了微信支付（这边我们可能会怀疑是key或者微信后台填写应用签名的问题，但是如果微信登录或分享能使用，就代表不是上诉问题，很大可能是因为sign的问题），中间查了很多资料才发现需要签名两次，移动端调起微信支付的时候提交的sign不能是微信接口直接返回来的sign，而应该是将调起微信支付前面6个参数再进行签名一次，算法与之前签名一致，多谢这位兄台的博客qq_28746251 主要的sign拿到后 不出错的话即可成功调出微信支付界面，真是千呼万唤“死”出来啊！后面就是回调逻辑的处理，建议在本地微信支付回调成功之后，再次到服务端发起支付确认 服务端支付认证分为两种： 微信回调 ：微信主动推送支付结果 查询订单 ：app服务端主动请求微信api查询支付结果","categories":[{"name":"Android","slug":"Android","permalink":"http://hwzhang.top/categories/Android/"}],"tags":[{"name":"android第三方接入","slug":"android第三方接入","permalink":"http://hwzhang.top/tags/android第三方接入/"}]},{"title":"android开发中常用的工具类积累","slug":"android-utils","date":"2016-09-01T11:50:25.000Z","updated":"2017-03-22T04:00:39.000Z","comments":true,"path":"2016/09/01/android-utils/","link":"","permalink":"http://hwzhang.top/2016/09/01/android-utils/","excerpt":"","text":"主要积累一些开发中比较 常用的工具类，部分借鉴于网络，部分来源于平时开发因需求而生的小工具1、LogUtil12345678910111213141516171819202122232425262728293031323334353637383940414243444546import android.util.Log;/** * LEVEL = VERBOSE时打印所有调试信息 * 当项目上线时，改为 LEVEL = NOTHING * 关闭所有打印信息 * @author 81091 * */public class LogUtil &#123; public static final int VERBOSE = 1; public static final int DEBUG = 2; public static final int INFO = 3; public static final int WARN = 4; public static final int ERROR = 5; public static final int NOTHING = 6; public static final int LEVEL = VERBOSE;//打印所有等级的信息// public static final int LEVEL = NOTHING;//关闭所有等级的信息 public static void v(String tag,String msg)&#123; if(LEVEL &lt;= VERBOSE)&#123; Log.v(tag,msg); &#125; &#125; public static void d(String tag,String msg)&#123; if(LEVEL &lt;= DEBUG)&#123; Log.d(tag,msg); &#125; &#125; public static void i(String tag,String msg)&#123; if(LEVEL &lt;= INFO)&#123; Log.i(tag,msg); &#125; &#125; public static void w(String tag,String msg)&#123; if(LEVEL &lt;= WARN)&#123; Log.w(tag,msg); &#125; &#125; public static void e(String tag,String msg)&#123; if(LEVEL &lt;= ERROR)&#123; Log.e(tag,msg); &#125; &#125; &#125; 2、MD5Utils1234567891011121314151617181920212223242526272829303132/** * 32位小写 * Created by C5-0 on 2015/7/25. */public class MD5Utils &#123; public static String ecodeTwice(String str) &#123;//MD5两次 return ecode(ecode(str)); &#125; public static String ecode(String passwd) &#123; try &#123; MessageDigest instance = MessageDigest.getInstance(\"MD5\"); byte[] digest = instance.digest(passwd.getBytes()); StringBuilder sb = new StringBuilder(); for (byte b : digest) &#123; int i = b &amp; 0xff; String hexString = Integer.toHexString(i); if (hexString.length() &lt; 2) &#123; hexString = \"0\" + hexString; &#125; sb.append(hexString); &#125; return sb.toString(); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; return \"\"; &#125;&#125; 3、比较常用的正则表达式验证123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116/** * Created by Administrator on 2016/8/10. */public class RegularUtils &#123; private RegularUtils() &#123; throw new UnsupportedOperationException(\"u can't fuck me...\"); &#125; /** * 验证手机号（简单） */ private static final String REGEX_MOBILE_SIMPLE = \"^[1]\\\\d&#123;10&#125;$\"; /** * 验证手机号（精确） * &lt;p&gt; * &lt;p&gt;移动：134(0-8)、135、136、137、138、139、147、150、151、152、157、158、159、178、182、183、184、187、188 * &lt;p&gt;联通：130、131、132、145、155、156、175、176、185、186 * &lt;p&gt;电信：133、153、173、177、180、181、189 * &lt;p&gt;全球星：1349 * &lt;p&gt;虚拟运营商：170 */ private static final String REGEX_MOBILE_EXACT = \"^((13[0-9])|(14[5,7])|(15[0-3,5-8])|(17[0,3,5-8])|(18[0-9])|(147))\\\\d&#123;8&#125;$\"; /** * 验证座机号,正确格式：xxx/xxxx-xxxxxxx/xxxxxxxx/ */ private static final String REGEX_TEL = \"^0\\\\d&#123;2,3&#125;[- ]?\\\\d&#123;7,8&#125;\"; /** * 验证邮箱 */ private static final String REGEX_EMAIL = \"^\\\\w+([-+.]\\\\w+)*@\\\\w+([-.]\\\\w+)*\\\\.\\\\w+([-.]\\\\w+)*$\"; /** * 验证url */ private static final String REGEX_URL = \"http(s)?://([\\\\w-]+\\\\.)+[\\\\w-]+(/[\\\\w-./?%&amp;=]*)?\"; /** * 验证汉字 */ private static final String REGEX_CHZ = \"^[\\\\u4e00-\\\\u9fa5]+$\"; /** * 验证用户名,取值范围为a-z,A-Z,0-9,\"_\",汉字，不能以\"_\"结尾,用户名必须是6-20位 */ private static final String REGEX_USERNAME = \"^[\\\\w\\\\u4e00-\\\\u9fa5]&#123;6,20&#125;(?&lt;!_)$\"; /** * 验证IP地址 */ private static final String REGEX_IP = \"((2[0-4]\\\\d|25[0-5]|[01]?\\\\d\\\\d?)\\\\.)&#123;3&#125;(2[0-4]\\\\d|25[0-5]|[01]?\\\\d\\\\d?)\"; //If u want more please visit http://toutiao.com/i6231678548520731137/ /** * @param string 待验证文本 * @return 是否符合手机号（简单）格式 */ public static boolean isMobileSimple(String string) &#123; return isMatch(REGEX_MOBILE_SIMPLE, string); &#125; /** * @param string 待验证文本 * @return 是否符合手机号（精确）格式 */ public static boolean isMobileExact(String string) &#123; return isMatch(REGEX_MOBILE_EXACT, string); &#125; /** * @param string 待验证文本 * @return 是否符合座机号码格式 */ public static boolean isTel(String string) &#123; return isMatch(REGEX_TEL, string); &#125; /** * @param string 待验证文本 * @return 是否符合邮箱格式 */ public static boolean isEmail(String string) &#123; return isMatch(REGEX_EMAIL, string); &#125; /** * @param string 待验证文本 * @return 是否符合网址格式 */ public static boolean isURL(String string) &#123; return isMatch(REGEX_URL, string); &#125; /** * @param string 待验证文本 * @return 是否符合汉字 */ public static boolean isChz(String string) &#123; return isMatch(REGEX_CHZ, string); &#125; /** * @param string 待验证文本 * @return 是否符合用户名 */ public static boolean isUsername(String string) &#123; return isMatch(REGEX_USERNAME, string); &#125; /** * @param regex 正则表达式字符串 * @param string 要匹配的字符串 * @return 如果str 符合 regex的正则表达式格式,返回true, 否则返回 false; */ public static boolean isMatch(String regex, String string) &#123; return !TextUtils.isEmpty(string) &amp;&amp; Pattern.matches(regex, string); &#125;&#125; 4、像素相关，获取Android屏幕宽度，控件宽度，dp跟px互转1234567891011121314151617181920212223242526272829303132333435public class PixelUtil &#123; //获取运行屏幕宽度 public static int getScreenWidth(Activity context) &#123; DisplayMetrics dm = new DisplayMetrics(); context.getWindowManager().getDefaultDisplay().getMetrics(dm); //宽度 dm.widthPixels //高度 dm.heightPixels// LogUtil.i(\"info\", \"getScreenWidth\" + dm.widthPixels); return dm.widthPixels; &#125; /** * 获取控件宽 */ public static int getWidth(View view) &#123; int w = View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED); int h = View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED); view.measure(w, h); return (view.getMeasuredWidth()); &#125; //DP转PX public static int dp2px(Activity context, float dpValue) &#123; final float scale = context.getResources().getDisplayMetrics().density; return (int) (dpValue * scale + 0.5f); &#125; //PX转DP public static int px2dp(Activity context, float pxValue) &#123; final float scale = context.getResources().getDisplayMetrics().density; return (int) (pxValue / scale + 0.5f); &#125;&#125; 5、去除double类型数字尾巴的0如：50.00 –&gt; 5012345public class MathDataUtil &#123; public static BigDecimal stripTrailingZeros(double d) &#123;//去除double尾巴的0 return new BigDecimal(d).stripTrailingZeros(); &#125;&#125; 6、时间戳相关123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102public class DateUtils &#123; private static SimpleDateFormat sf; private static SimpleDateFormat sdf; /** * 获取系统时间 格式为：\"yyyy/MM/dd \" **/ public static String getCurrentDate() &#123; Date d = new Date(); sf = new SimpleDateFormat(\"yyyy年MM月dd日\"); return sf.format(d); &#125; /** * 获取系统时间 格式为：\"yyyy \" **/ public static String getCurrentYear() &#123; Date d = new Date(); sf = new SimpleDateFormat(\"yyyy\"); return sf.format(d); &#125; /** * 获取系统时间 格式为：\"MM\" **/ public static String getCurrentMonth() &#123; Date d = new Date(); sf = new SimpleDateFormat(\"MM\"); return sf.format(d); &#125; /** * 获取系统时间 格式为：\"dd\" **/ public static String getCurrentDay() &#123; Date d = new Date(); sf = new SimpleDateFormat(\"dd\"); return sf.format(d); &#125; /** * 获取当前时间戳 * * @return */ public static long getCurrentTime() &#123; long d = new Date().getTime() / 1000; return d; &#125; /** * 时间戳转换成字符窜 */ public static String getDateToString(long time) &#123; Date d = new Date(time * 1000); sf = new SimpleDateFormat(\"yyyy年MM月dd日\"); return sf.format(d); &#125; /** * 时间戳中获取年 */ public static String getYearFromTime(long time) &#123; Date d = new Date(time * 1000); sf = new SimpleDateFormat(\"yyyy\"); return sf.format(d); &#125; /** * 时间戳中获取月 */ public static String getMonthFromTime(long time) &#123; Date d = new Date(time * 1000); sf = new SimpleDateFormat(\"MM\"); return sf.format(d); &#125; /** * 时间戳中获取日 */ public static String getDayFromTime(long time) &#123; Date d = new Date(time * 1000); sf = new SimpleDateFormat(\"dd\"); return sf.format(d); &#125; /** * 将字符串转为时间戳 */ public static long getStringToDate(String time) &#123; sdf = new SimpleDateFormat(\"yyyy年MM月dd日\"); Date date = new Date(); try &#123; date = sdf.parse(time); &#125; catch (ParseException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return date.getTime(); &#125;&#125; 7、文件相关123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687public class FileUtils &#123; public static String SDPATH = Environment.getExternalStorageDirectory() + \"/formats/\";// 获取文件夹 // 保存图片 public static boolean saveBitmap(Bitmap mBitmap, String path, String imgName) &#123; String sdStatus = Environment.getExternalStorageState(); if (!sdStatus.equals(Environment.MEDIA_MOUNTED)) &#123; // 检测sd是否可用 return false; &#125; FileOutputStream b = null; File file = new File(path); file.mkdirs();// 创建文件夹 String fileName = path + imgName;// delFile(path, imgName);//删除本地旧图 try &#123; b = new FileOutputStream(fileName); mBitmap.compress(Bitmap.CompressFormat.JPEG, 100, b);// 把数据写入文件 &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; b.flush(); b.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; return true; &#125; public static File createSDDir(String dirName) throws IOException &#123; File dir = new File(SDPATH + dirName); if (Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) &#123; System.out.println(\"createSDDir:\" + dir.getAbsolutePath()); System.out.println(\"createSDDir:\" + dir.mkdir()); &#125; return dir; &#125; public static boolean isFileExist(String fileName) &#123; File file = new File(SDPATH + fileName); file.isFile(); return file.exists(); &#125; // 删除文件 public static void delFile(String path, String fileName) &#123; File file = new File(path + fileName); if (file.isFile()) &#123; file.delete(); &#125; file.exists(); &#125; // 删除文件夹和文件夹里面的文件 public static void deleteDir() &#123; File dir = new File(SDPATH); if (dir == null || !dir.exists() || !dir.isDirectory()) return; for (File file : dir.listFiles()) &#123; if (file.isFile()) file.delete(); // 删除所有文件 else if (file.isDirectory()) deleteDir(); // 递规的方式删除文件夹 &#125; dir.delete();// 删除目录本身 &#125; public static boolean fileIsExists(String path) &#123; try &#123; File f = new File(path); if (!f.exists()) &#123; return false; &#125; &#125; catch (Exception e) &#123; return false; &#125; return true; &#125;&#125; 8、AlertDialogUtil123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Created by david on 2016/8/26. * * 使用观察者模式来实现确定结果回调 * * 调用方式： * AlertDialogUtil dialogUtil = new AlertDialogUtil(context); * dialogUtil.showDialog(\"确定删除已上传的图片？\"); * dialogUtil.setDialogPositiveButtonListener(new AlertDialogUtil.DialogPositiveButtonListener() &#123; * * @Override * public void setDialogPositiveButtonListener() &#123; * * &#125; * &#125;); */public class AlertDialogUtil &#123; public Context context; private DialogPositiveButtonListener listener; public AlertDialogUtil(Context context) &#123; this.context = context; &#125; public void showDialog(String message) &#123; AlertDialog.Builder dialog = new AlertDialog.Builder(context); dialog.setMessage(message); dialog.setCancelable(false);//点击框外取消 dialog.setPositiveButton(\"确定\", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialogInterface, int i) &#123; if (listener != null) &#123; listener.setDialogPositiveButtonListener(); &#125; &#125; &#125;); dialog.setNegativeButton(\"取消\", null); dialog.show(); &#125; public void setDialogPositiveButtonListener(DialogPositiveButtonListener listener) &#123; this.listener = listener; &#125; public interface DialogPositiveButtonListener &#123; void setDialogPositiveButtonListener(); &#125;&#125; 9、ToastUtil1234567891011121314151617181920212223242526272829303132333435public class ToastUtils &#123; static Toast toast; private ToastUtils() &#123; throw new AssertionError(); &#125; public static void show(Context paramContext, int paramInt) &#123; show(paramContext, paramContext.getResources().getText(paramInt), 0); &#125; public static void show(Context paramContext, int paramInt1, int paramInt2) &#123; show(paramContext, paramContext.getResources().getText(paramInt1), paramInt2); &#125; public static void show(Context paramContext, CharSequence paramCharSequence) &#123; show(paramContext, paramCharSequence, 0); &#125; public static void show(Context paramContext, CharSequence paramCharSequence, int paramInt) &#123; if (toast != null) &#123; toast.setText(paramCharSequence); toast.setDuration(paramInt); toast.show();// return; &#125; toast = Toast.makeText(paramContext, paramCharSequence, paramInt); toast.show(); &#125; public static void toastCancle() &#123; if (toast != null) toast.cancel(); &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://hwzhang.top/categories/Android/"}],"tags":[{"name":"android开发工具","slug":"android开发工具","permalink":"http://hwzhang.top/tags/android开发工具/"}]},{"title":"androidv4包下拉刷新布局SwipeRefreshLayout","slug":"SwipeLayout","date":"2016-07-15T12:09:32.000Z","updated":"2017-03-22T04:00:54.000Z","comments":true,"path":"2016/07/15/SwipeLayout/","link":"","permalink":"http://hwzhang.top/2016/07/15/SwipeLayout/","excerpt":"","text":"如何使用123456789101112131415161718192021&lt;android.support.v4.widget.SwipeRefreshLayout android:id=&quot;@+id/wifi_swipe_refresh&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:layout_below=&quot;@+id/fl_title&quot;&gt; &lt;android.support.v7.widget.RecyclerView android:id=&quot;@+id/rv_wifi_table&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt;&lt;/android.support.v4.widget.SwipeRefreshLayout&gt;wifi_swipe_refresh = (SwipeRefreshLayout) findViewById(R.id.wifi_swipe_refresh);wifi_swipe_refresh.setOnRefreshListener(this);//SwipeRefreshLayout.OnRefreshListenerwifi_swipe_refresh.setColorSchemeResources( R.color.google_blue, R.color.google_green, R.color.google_red, R.color.google_yellow); 上述监听事件（这里使用 RxJava实现异步操作） 1234567891011121314@Overridepublic void onRefresh() &#123; Observable.timer(1, TimeUnit.SECONDS, AndroidSchedulers.mainThread()).map(new Func1&lt;Long, Object&gt;() &#123; @Override public Object call(Long aLong) &#123; initData(); if (null != wifi_swipe_refresh) &#123; wifi_swipe_refresh.setRefreshing(false); &#125; return null; &#125; &#125;).subscribe();&#125; 进入时加载circleview 加载动画：1、默认setRefreshing(true)方法，无法实线初次加载显示动画的效果。我们可以这样处理：1234swipeRefreshLayout.setProgressViewOffset(false, 0, (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 24, getResources(). getDisplayMetrics()));swipeRefreshLayout.setRefreshing(true);.0 2、使用swipeRefreshLayout.post()方式来加载显示动画123456 swipeRefreshLayout.post(new Runnable() &#123; @Override public void run() &#123; swipeRefreshLayout.setRefreshing(true); &#125;&#125;); 关闭circleview 加载动画：由于子线程中不能更新UI，所以需要通过hander来定时关闭加载动画使用handler计时 定时关闭12345678 final Handler handler = new Handler(); handler.postDelayed(new Runnable() &#123; @Override public void run() &#123; swipeRefreshLayout.setRefreshing(false); &#125;&#125;,2000);//2000ms后取消（关闭） 避免刷新过程中仍可以操作界面,自定义SwipeRefreshLayout，通过父类拿到refresh状态，从而进行事件的传递机制控制1234567891011121314public class MySwipeRefreshLayout extends SwipeRefreshLayout &#123; public MySwipeRefreshLayout(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; @Override public boolean onInterceptTouchEvent(MotionEvent ev) &#123; if (super.isRefreshing()) &#123;//调用父view中的isRefreshing（）方法，从而拿到刷新状态。刷新时消化点击事件 return true; &#125; return super.onInterceptTouchEvent(ev); &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://hwzhang.top/categories/Android/"}],"tags":[{"name":"android-widget-study","slug":"android-widget-study","permalink":"http://hwzhang.top/tags/android-widget-study/"}]},{"title":"okHttp3.0入门","slug":"okhttp-introduction","date":"2016-07-10T14:03:58.000Z","updated":"2017-03-22T04:00:49.000Z","comments":true,"path":"2016/07/10/okhttp-introduction/","link":"","permalink":"http://hwzhang.top/2016/07/10/okhttp-introduction/","excerpt":"","text":"最近身边越来越多的小伙伴提到okHttp，于是我也打算趁着新项目开始前着手学习一下okhttp，并且希望能在新项目中用起来。Google了一些材料，照着文档写了简单的demo，并且做了最简单的封装。每个项目中的网络请求接口一般都不会太少，所以不封装是不靠谱的，然而okHttp确实封装起来比较麻烦一些。 OkHttp官网地址： http://square.github.io/okhttp/ OkHttp GitHub地址：https://github.com/square/okhttp 配置方法 导入jar包 1compile &apos;com.squareup.okhttp3:okhttp:3.3.1&apos; 开启网络权限不解释。 基础用法介绍，GET，POST请求，同步，异步同步Http GET请求1234567891011121314151617181920OkHttpClient client = new OkHttpClient();private void httpGet(String url) throws IOException &#123; final Request request = new Request.Builder() .get() .tag(this) .url(url) .build();//Request是OkHttp中访问的请求，Builder是辅助类，Response即OkHttp中的响应 final Response response = client.newCall(request).execute(); if (response.isSuccessful()) &#123; return response.body().string(); &#125; else &#123; throw new IOException(\"Unexpected code \" + response); &#125;&#125; /** * onResponse回调的参数是response，一般情况下，比如 * 我们希望获得返回的字符串，可以通过response.body().string()获取； * 如果希望获得返回的二进制字节数组，则调用response.body().bytes()； * 如果你想拿到返回的inputStream，则调用response.body().byteStream() */ 同步Http POST请求12345678910111213141516171819202122232425262728293031323334353637//POST提交键值对 OkHttpClient client = new OkHttpClient();private void httpPost(String url) throws IOException &#123; RequestBody formBody = new FormBody.Builder() .add(\"u_Phone\", \"10086\")//传入参数 .add(\"code\", \"111111\")//传入参数 .add(\"encodestr\", MD5Utils.ecodeTwice(\"10086\" + \"111111\" + \"action_login\"))//传入参数 .build(); final Request request = new Request.Builder() .url(url) .post(formBody) .build(); final Response response = client.newCall(request).execute(); if (response.isSuccessful()) &#123; return response.body().string(); &#125; else &#123; throw new IOException(\"Unexpected code \" + response); &#125;&#125;//POST提交Json数据 public static final MediaType JSON = MediaType.parse(\"application/json; charset=utf-8\");OkHttpClient client = new OkHttpClient();String post(String url, String json) throws IOException &#123; RequestBody body = RequestBody.create(JSON, json); Request request = new Request.Builder() .url(url) .post(body) .build(); Response response = client.newCall(request).execute(); f (response.isSuccessful()) &#123; return response.body().string(); &#125; else &#123; throw new IOException(\"Unexpected code \" + response); &#125;&#125; 异步 Http Get1234567891011121314151617181920212223242526private void asyGet(String url) throws IOException &#123; final Request request = new Request.Builder() .get() .tag(this) .url(url) .build();//Request是OkHttp中访问的请求，Builder是辅助类，Response即OkHttp中的响应 final Response response = client.newCall(request).execute(); Call call = client.newCall(request); /** * 我们希望以异步的方式去执行请求，所以我们调用的是call.enqueue，将call加入调度队列，然后等待任务执行完成，我们在Callback中即可得到结果。 */ call.enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; try &#123; throw new IOException(\"UnException code\" + response); &#125; catch (IOException e1) &#123; e1.printStackTrace(); &#125; &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; Log.i(\"info\", \"打印GET响应的数据：:\" + response.body().string()); &#125; &#125;); &#125; 异步HTTP Post123456789101112131415161718192021private void asyPost(String url) throws IOException &#123; RequestBody formBody = new FormBody.Builder() .add(\"u_Phone\", \"10086\") .add(\"code\", \"111111\") .add(\"encodestr\", MD5Utils.ecodeTwice(\"10086\" + \"111111\" + \"action_login\")) .build(); final Request request = new Request.Builder() .url(url) .post(formBody) .build(); client.newCall(request).enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; Log.e(\"info\", String.valueOf(e)); &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; Log.i(\"info\", \"打印POST响应的数据：\" + response.body().string()); &#125; &#125;);&#125; 看了基本用法后是不是感觉入门也是十分简单，跟volley十分相似，但是有一点却是十分懵逼的- -。因为volley的每一个请求都需要加入到请求队列中，并且可以使用tag来取消当前网络请求,如下：1requestQueue.add(req); 于是用惯了volley的我就不能忍了，于是乎查资料，发现在okhttp的用法跟volley不一样，所以这个一时我就找不到这个tag的作用，一脸懵逼状- -。只允许设置tag，却没法用tag给取消这个请求，kiding me？ 想想这么流行的框架不可能会留下这种低级错误啊，于是乎查看源码（似懂非懂–），Google，终于找到对应的解决方式：123456789101112131415161718public void cancelCallsWithTag(Object tag)&#123; if (tag == null || mOkHttpClient == null) &#123; return; &#125; synchronized (mOkHttpClient.dispatcher().getClass()) &#123; for (Call call : mOkHttpClient.dispatcher().queuedCalls()) &#123; if (tag.equals(call.request().tag())) &#123; call.cancel(); &#125; &#125; for (Call call : mOkHttpClient.dispatcher().runningCalls()) &#123; if (tag.equals(call.request().tag())) call.cancel(); &#125; &#125;&#125; 最基本的用法了解了，是时候该着手进行简单的封装这里主要用到 OkHttpClientManager类，与回调接收接口ResultCallback偷懒一下 ，直接贴源码了，相应解释直接在代码中注释：1234567891011package com.okhttpstudy.okhttp;/** * Created by hwei on 2016/7/8. */public interface ResultCallback &#123; public abstract void onError(String msg); public abstract void onResponse(String result);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148/** * Created by hwei on 2016/7/8. */ public class OkHttpClientManager &#123; private static OkHttpClientManager instance; private OkHttpClient mOkHttpClient; private static final String TAG = \"OkHttpClientManager\"; public OkHttpClientManager() &#123; //mOkHttpClient = new OkHttpClient(); mOkHttpClient = new OkHttpClient.Builder() .connectTimeout(1000l, TimeUnit.MILLISECONDS) .readTimeout(10000L, TimeUnit.MILLISECONDS) //.cache(cache) .build(); //cookie enabled //cookie相关的东西还有很多需要研究，以后慢慢补充// mOkHttpClient.cookieJar(new CookieManager(null, CookiePolicy.ACCEPT_ORIGINAL_SERVER)); &#125; public static OkHttpClientManager getInstance() &#123; if (instance == null) &#123; synchronized (OkHttpClientManager.class) &#123; if (instance == null) &#123; instance = new OkHttpClientManager(); &#125; &#125; &#125; return instance; &#125; public void cancelCallsWithTag(Object tag) &#123; if (tag == null || mOkHttpClient == null) &#123; return; &#125; synchronized (mOkHttpClient.dispatcher().getClass()) &#123; for (Call call : mOkHttpClient.dispatcher().queuedCalls()) &#123; if (tag.equals(call.request().tag())) &#123; call.cancel(); &#125; &#125; for (Call call : mOkHttpClient.dispatcher().runningCalls()) &#123; if (tag.equals(call.request().tag())) call.cancel(); &#125; &#125; &#125; public void getAsyn(final Activity activity, String url, Map&lt;String, String&gt; requestmap, final ResultCallback callback) &#123; final Request request = new Request.Builder() .get() .tag(activity.getClass().getSimpleName()) .url(onBuildGetParams(url, requestmap))//get请求，参数拼接 .build();//Request是OkHttp中访问的请求，Builder是辅助类，Response即OkHttp中的响应 Call call = mOkHttpClient.newCall(request); call.enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; callback.onError(String.valueOf(e)); &#125; /** * * @param call * @param response * @throws IOException * onResponse回调的参数是response，一般情况下，比如 * 我们希望获得返回的字符串，可以通过response.body().string()获取； * 如果希望获得返回的二进制字节数组，则调用response.body().bytes()； * 如果你想拿到返回的inputStream，则调用response.body().byteStream() */ @Override public void onResponse(Call call, final Response response) throws IOException &#123; if (response.isSuccessful()) &#123; activity.runOnUiThread(new Runnable() &#123;//用惯了volley的人初次搞这个可能都会习惯直接调用ui线程去更新ui，然后okhttp在这一点上一点却让人“不太省心”，我们必须自己进行线程切换 @Override public void run() &#123; try &#123; callback.onResponse(response.body().string()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125; &#125; &#125;); &#125; public void postAsyn(final Activity activity, String url, Map&lt;String, String&gt; requestmap, final ResultCallback callback) &#123; MediaType JSON = MediaType.parse(\"application/json; charset=utf-8\"); JSONObject jsonObject = new JSONObject(requestmap); RequestBody requestBody = RequestBody.create(JSON, String.valueOf(jsonObject)); LogUti.i(\"info\", \"requestmapJson\" + String.valueOf(jsonObject)); Request request = new Request.Builder() .url(url) .tag(activity.getClass().getSimpleName()) .post(requestBody) .build(); Call call = mOkHttpClient.newCall(request); call.enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; callback.onError(String.valueOf(e)); &#125; @Override public void onResponse(Call call, final Response response) throws IOException &#123; if (response.isSuccessful()) &#123; activity.runOnUiThread(new Runnable() &#123; @Override public void run() &#123; try &#123; callback.onResponse(response.body().string()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125; &#125; &#125;); &#125;/*** get请求参数的封装，构造成与POST同样的调用方式*/ private String onBuildGetParams(String url, Map&lt;String, String&gt; map) &#123; StringBuilder sb = new StringBuilder(url); boolean isFirst = true; if (map == null) &#123;//没有参数时 直接返回url return sb.toString(); &#125; for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123; if (isFirst) &#123; isFirst = false; sb.append(\"?\" + entry.getKey() + \"=\" + entry.getValue()); &#125; else &#123; sb.append(\"&amp;\" + entry.getKey() + \"=\" + entry.getValue()); &#125; &#125; LogUti.i(\"info\", \"url\" + sb.toString()); return sb.toString(); &#125;&#125; 如何使用：123456789101112131415161718192021222324252627282930313233343536373839404142434445//调用post请求Map&lt;String,String&gt; map = new HashMap&lt;&gt;();map.put(\"u_Phone\",\"10086\");map.put(\"url\",\"http://simple.cn/Service.php?a=checkMobile\");map.put(\"code\",\"111111\");map.put(\"encodestr\",MD5Utils.ecodeTwice(\"10086\" + \"111111\" + \"action_login\"));OkHttpClientManager.getInstance().postAsyn(this,\"http://simple.cn/Service.php?a=checkMobile\", map, new ResultCallback() &#123; @Override public void onError(String msg) &#123; LogUti.i(\"info\",\"post onError\" + msg); &#125; @Override public void onResponse(final String result) &#123; Toast.makeText(MainActivity.this,\"result\"+result ,Toast.LENGTH_LONG).show(); LogUti.i(\"info\",\"post onResponse result:\" + result.toString()); &#125;&#125;);//调用get请求Map&lt;String,String&gt; map = new HashMap&lt;&gt;(); map.put(\"u_Phone\",\"10086\"); map.put(\"url\",\"http://simple.cn/Service.php?a=checkMobile\"); map.put(\"code\",\"111111\"); map.put(\"encodestr\",MD5Utils.ecodeTwice(\"simple\" + \"111111\" + \"action_login\")); OkHttpClientManager.getInstance().postAsyn(this,\"http://simple.cn/Service.php?a=checkMobile\", map, new ResultCallback() &#123; @Override public void onError(String msg) &#123; LogUti.i(\"info\",\"post onError\" + msg); &#125; @Override public void onResponse(final String result) &#123; Toast.makeText(MainActivity.this,\"result\"+result ,Toast.LENGTH_LONG).show(); LogUti.i(\"info\",\"post onResponse result:\" + result.toString()); &#125; &#125;);//我们可以在每个页面销毁前取消对应tag的网络请求@Override protected void onDestroy() &#123; super.onDestroy(); OkHttpClientManager.getInstance().cancelCallsWithTag(tag); &#125; 只是简单的进行了封装，直接将网络响应结果回调给每个Activity，而没有进行统一的解析，这里有待改进。。。","categories":[{"name":"Android","slug":"Android","permalink":"http://hwzhang.top/categories/Android/"}],"tags":[{"name":"android-开源项目学习","slug":"android-开源项目学习","permalink":"http://hwzhang.top/tags/android-开源项目学习/"}]}]}